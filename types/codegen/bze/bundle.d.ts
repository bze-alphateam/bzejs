import * as _1 from "../beezee/burner/burn_coins_proposal";
import * as _2 from "../beezee/burner/burned_coins";
import * as _3 from "../beezee/burner/events";
import * as _4 from "../beezee/burner/genesis";
import * as _5 from "../beezee/burner/params";
import * as _6 from "../beezee/burner/query";
import * as _7 from "../beezee/burner/raffle";
import * as _8 from "../beezee/burner/tx";
import * as _9 from "../beezee/cointrunk/accepted_domain_proposal";
import * as _10 from "../beezee/cointrunk/accepted_domain";
import * as _11 from "../beezee/cointrunk/anon_articles_counter";
import * as _12 from "../beezee/cointrunk/article";
import * as _13 from "../beezee/cointrunk/events";
import * as _14 from "../beezee/cointrunk/genesis";
import * as _15 from "../beezee/cointrunk/params";
import * as _16 from "../beezee/cointrunk/publisher_proposal";
import * as _17 from "../beezee/cointrunk/publisher";
import * as _18 from "../beezee/cointrunk/query";
import * as _19 from "../beezee/cointrunk/tx";
import * as _20 from "../beezee/epochs/events";
import * as _21 from "../beezee/epochs/genesis";
import * as _22 from "../beezee/epochs/query";
import * as _23 from "../beezee/rewards/events";
import * as _24 from "../beezee/rewards/genesis";
import * as _25 from "../beezee/rewards/gov";
import * as _26 from "../beezee/rewards/params";
import * as _27 from "../beezee/rewards/query";
import * as _28 from "../beezee/rewards/staking_reward_participant";
import * as _29 from "../beezee/rewards/staking_reward";
import * as _30 from "../beezee/rewards/trading_reward";
import * as _31 from "../beezee/rewards/tx";
import * as _32 from "../beezee/tokenfactory/denom_authority";
import * as _33 from "../beezee/tokenfactory/genesis";
import * as _34 from "../beezee/tokenfactory/params";
import * as _35 from "../beezee/tokenfactory/query";
import * as _36 from "../beezee/tokenfactory/tx";
import * as _37 from "../beezee/tradebin/events";
import * as _38 from "../beezee/tradebin/genesis";
import * as _39 from "../beezee/tradebin/market";
import * as _40 from "../beezee/tradebin/order";
import * as _41 from "../beezee/tradebin/params";
import * as _42 from "../beezee/tradebin/query";
import * as _43 from "../beezee/tradebin/queue_message";
import * as _44 from "../beezee/tradebin/tx";
import * as _192 from "../beezee/burner/query.lcd";
import * as _193 from "../beezee/cointrunk/query.lcd";
import * as _194 from "../beezee/epochs/query.lcd";
import * as _195 from "../beezee/rewards/query.lcd";
import * as _196 from "../beezee/tokenfactory/query.lcd";
import * as _197 from "../beezee/tradebin/query.lcd";
import * as _198 from "../beezee/burner/query.rpc.Query";
import * as _199 from "../beezee/cointrunk/query.rpc.Query";
import * as _200 from "../beezee/epochs/query.rpc.Query";
import * as _201 from "../beezee/rewards/query.rpc.Query";
import * as _202 from "../beezee/tokenfactory/query.rpc.Query";
import * as _203 from "../beezee/tradebin/query.rpc.Query";
import * as _204 from "../beezee/burner/tx.rpc.msg";
import * as _205 from "../beezee/cointrunk/tx.rpc.msg";
import * as _206 from "../beezee/rewards/tx.rpc.msg";
import * as _207 from "../beezee/tokenfactory/tx.rpc.msg";
import * as _208 from "../beezee/tradebin/tx.rpc.msg";
export declare namespace bze {
    namespace burner {
        const v1: {
            MsgClientImpl: typeof _204.MsgClientImpl;
            QueryClientImpl: typeof _198.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _6.QueryParamsRequest): Promise<_6.QueryParamsResponse>;
                raffles(request?: _6.QueryRafflesRequest): Promise<_6.QueryRafflesResponse>;
                raffleWinners(request: _6.QueryRaffleWinnersRequest): Promise<_6.QueryRaffleWinnersResponse>;
                allBurnedCoins(request?: _6.QueryAllBurnedCoinsRequest): Promise<_6.QueryAllBurnedCoinsResponse>;
            };
            LCDQueryClient: typeof _192.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    fundBurner(value: _8.MsgFundBurner): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    startRaffle(value: _8.MsgStartRaffle): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    joinRaffle(value: _8.MsgJoinRaffle): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    fundBurner(value: _8.MsgFundBurner): {
                        typeUrl: string;
                        value: _8.MsgFundBurner;
                    };
                    startRaffle(value: _8.MsgStartRaffle): {
                        typeUrl: string;
                        value: _8.MsgStartRaffle;
                    };
                    joinRaffle(value: _8.MsgJoinRaffle): {
                        typeUrl: string;
                        value: _8.MsgJoinRaffle;
                    };
                };
                fromPartial: {
                    fundBurner(value: _8.MsgFundBurner): {
                        typeUrl: string;
                        value: _8.MsgFundBurner;
                    };
                    startRaffle(value: _8.MsgStartRaffle): {
                        typeUrl: string;
                        value: _8.MsgStartRaffle;
                    };
                    joinRaffle(value: _8.MsgJoinRaffle): {
                        typeUrl: string;
                        value: _8.MsgJoinRaffle;
                    };
                };
            };
            AminoConverter: {
                "/bze.burner.v1.MsgFundBurner": {
                    aminoType: string;
                    toAmino: ({ creator, amount }: _8.MsgFundBurner) => {
                        creator: string;
                        amount: string;
                    };
                    fromAmino: ({ creator, amount }: {
                        creator: string;
                        amount: string;
                    }) => _8.MsgFundBurner;
                };
                "/bze.burner.v1.MsgStartRaffle": {
                    aminoType: string;
                    toAmino: ({ creator, pot, duration, chances, ratio, ticketPrice, denom }: _8.MsgStartRaffle) => {
                        creator: string;
                        pot: string;
                        duration: string;
                        chances: string;
                        ratio: string;
                        ticket_price: string;
                        denom: string;
                    };
                    fromAmino: ({ creator, pot, duration, chances, ratio, ticket_price, denom }: {
                        creator: string;
                        pot: string;
                        duration: string;
                        chances: string;
                        ratio: string;
                        ticket_price: string;
                        denom: string;
                    }) => _8.MsgStartRaffle;
                };
                "/bze.burner.v1.MsgJoinRaffle": {
                    aminoType: string;
                    toAmino: ({ creator, denom }: _8.MsgJoinRaffle) => {
                        creator: string;
                        denom: string;
                    };
                    fromAmino: ({ creator, denom }: {
                        creator: string;
                        denom: string;
                    }) => _8.MsgJoinRaffle;
                };
            };
            MsgFundBurner: {
                encode(message: _8.MsgFundBurner, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgFundBurner;
                fromPartial(object: {
                    creator?: string;
                    amount?: string;
                }): _8.MsgFundBurner;
            };
            MsgFundBurnerResponse: {
                encode(_: _8.MsgFundBurnerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgFundBurnerResponse;
                fromPartial(_: {}): _8.MsgFundBurnerResponse;
            };
            MsgStartRaffle: {
                encode(message: _8.MsgStartRaffle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgStartRaffle;
                fromPartial(object: {
                    creator?: string;
                    pot?: string;
                    duration?: string;
                    chances?: string;
                    ratio?: string;
                    ticketPrice?: string;
                    denom?: string;
                }): _8.MsgStartRaffle;
            };
            MsgStartRaffleResponse: {
                encode(_: _8.MsgStartRaffleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgStartRaffleResponse;
                fromPartial(_: {}): _8.MsgStartRaffleResponse;
            };
            MsgJoinRaffle: {
                encode(message: _8.MsgJoinRaffle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgJoinRaffle;
                fromPartial(object: {
                    creator?: string;
                    denom?: string;
                }): _8.MsgJoinRaffle;
            };
            MsgJoinRaffleResponse: {
                encode(_: _8.MsgJoinRaffleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _8.MsgJoinRaffleResponse;
                fromPartial(_: {}): _8.MsgJoinRaffleResponse;
            };
            Raffle: {
                encode(message: _7.Raffle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _7.Raffle;
                fromPartial(object: {
                    pot?: string;
                    duration?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    chances?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ratio?: string;
                    endAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    winners?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ticketPrice?: string;
                    denom?: string;
                    totalWon?: string;
                }): _7.Raffle;
            };
            RaffleDeleteHook: {
                encode(message: _7.RaffleDeleteHook, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _7.RaffleDeleteHook;
                fromPartial(object: {
                    denom?: string;
                    endAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _7.RaffleDeleteHook;
            };
            RaffleWinner: {
                encode(message: _7.RaffleWinner, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _7.RaffleWinner;
                fromPartial(object: {
                    index?: string;
                    denom?: string;
                    amount?: string;
                    winner?: string;
                }): _7.RaffleWinner;
            };
            RaffleParticipant: {
                encode(message: _7.RaffleParticipant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _7.RaffleParticipant;
                fromPartial(object: {
                    index?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    denom?: string;
                    participant?: string;
                    executeAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _7.RaffleParticipant;
            };
            QueryParamsRequest: {
                encode(_: _6.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryParamsRequest;
                fromPartial(_: {}): _6.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _6.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryParamsResponse;
                fromPartial(object: {
                    params?: {};
                }): _6.QueryParamsResponse;
            };
            QueryAllBurnedCoinsRequest: {
                encode(message: _6.QueryAllBurnedCoinsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryAllBurnedCoinsRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _6.QueryAllBurnedCoinsRequest;
            };
            QueryAllBurnedCoinsResponse: {
                encode(message: _6.QueryAllBurnedCoinsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryAllBurnedCoinsResponse;
                fromPartial(object: {
                    burnedCoins?: {
                        burned?: string;
                        height?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _6.QueryAllBurnedCoinsResponse;
            };
            QueryRafflesRequest: {
                encode(message: _6.QueryRafflesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryRafflesRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _6.QueryRafflesRequest;
            };
            QueryRafflesResponse: {
                encode(message: _6.QueryRafflesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryRafflesResponse;
                fromPartial(object: {
                    list?: {
                        pot?: string;
                        duration?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        chances?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        ratio?: string;
                        endAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        winners?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        ticketPrice?: string;
                        denom?: string;
                        totalWon?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _6.QueryRafflesResponse;
            };
            QueryRaffleWinnersRequest: {
                encode(message: _6.QueryRaffleWinnersRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryRaffleWinnersRequest;
                fromPartial(object: {
                    denom?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _6.QueryRaffleWinnersRequest;
            };
            QueryRaffleWinnersResponse: {
                encode(message: _6.QueryRaffleWinnersResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.QueryRaffleWinnersResponse;
                fromPartial(object: {
                    list?: {
                        index?: string;
                        denom?: string;
                        amount?: string;
                        winner?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _6.QueryRaffleWinnersResponse;
            };
            Params: {
                encode(_: _5.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _5.Params;
                fromPartial(_: {}): _5.Params;
            };
            GenesisState: {
                encode(message: _4.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _4.GenesisState;
                fromPartial(object: {
                    params?: {};
                    burnedCoinsList?: {
                        burned?: string;
                        height?: string;
                    }[];
                    raffleList?: {
                        pot?: string;
                        duration?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        chances?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        ratio?: string;
                        endAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        winners?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        ticketPrice?: string;
                        denom?: string;
                        totalWon?: string;
                    }[];
                    raffleWinnersList?: {
                        index?: string;
                        denom?: string;
                        amount?: string;
                        winner?: string;
                    }[];
                    raffleParticipantsList?: {
                        index?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        denom?: string;
                        participant?: string;
                        executeAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    raffleParticipantCounter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _4.GenesisState;
            };
            CoinsBurnedEvent: {
                encode(message: _3.CoinsBurnedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.CoinsBurnedEvent;
                fromPartial(object: {
                    burned?: string;
                }): _3.CoinsBurnedEvent;
            };
            FundBurnerEvent: {
                encode(message: _3.FundBurnerEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.FundBurnerEvent;
                fromPartial(object: {
                    from?: string;
                    amount?: string;
                }): _3.FundBurnerEvent;
            };
            RaffleWinnerEvent: {
                encode(message: _3.RaffleWinnerEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.RaffleWinnerEvent;
                fromPartial(object: {
                    denom?: string;
                    winner?: string;
                    amount?: string;
                }): _3.RaffleWinnerEvent;
            };
            RaffleLostEvent: {
                encode(message: _3.RaffleLostEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.RaffleLostEvent;
                fromPartial(object: {
                    denom?: string;
                    participant?: string;
                }): _3.RaffleLostEvent;
            };
            RaffleFinishedEvent: {
                encode(message: _3.RaffleFinishedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.RaffleFinishedEvent;
                fromPartial(object: {
                    denom?: string;
                }): _3.RaffleFinishedEvent;
            };
            BurnedCoins: {
                encode(message: _2.BurnedCoins, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _2.BurnedCoins;
                fromPartial(object: {
                    burned?: string;
                    height?: string;
                }): _2.BurnedCoins;
            };
            BurnCoinsProposal: {
                encode(message: _1.BurnCoinsProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _1.BurnCoinsProposal;
                fromPartial(object: {
                    title?: string;
                    description?: string;
                }): _1.BurnCoinsProposal;
            };
        };
    }
    namespace cointrunk {
        const v1: {
            MsgClientImpl: typeof _205.MsgClientImpl;
            QueryClientImpl: typeof _199.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _18.QueryParamsRequest): Promise<_18.QueryParamsResponse>;
                acceptedDomain(request?: _18.QueryAcceptedDomainRequest): Promise<_18.QueryAcceptedDomainResponse>;
                publisher(request?: _18.QueryPublisherRequest): Promise<_18.QueryPublisherResponse>;
                publisherByIndex(request: _18.QueryPublisherByIndexRequest): Promise<_18.QueryPublisherByIndexResponse>;
                allArticles(request?: _18.QueryAllArticlesRequest): Promise<_18.QueryAllArticlesResponse>;
                allAnonArticlesCounters(request?: _18.QueryAllAnonArticlesCountersRequest): Promise<_18.QueryAllAnonArticlesCountersResponse>;
            };
            LCDQueryClient: typeof _193.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    addArticle(value: _19.MsgAddArticle): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    payPublisherRespect(value: _19.MsgPayPublisherRespect): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    addArticle(value: _19.MsgAddArticle): {
                        typeUrl: string;
                        value: _19.MsgAddArticle;
                    };
                    payPublisherRespect(value: _19.MsgPayPublisherRespect): {
                        typeUrl: string;
                        value: _19.MsgPayPublisherRespect;
                    };
                };
                fromPartial: {
                    addArticle(value: _19.MsgAddArticle): {
                        typeUrl: string;
                        value: _19.MsgAddArticle;
                    };
                    payPublisherRespect(value: _19.MsgPayPublisherRespect): {
                        typeUrl: string;
                        value: _19.MsgPayPublisherRespect;
                    };
                };
            };
            AminoConverter: {
                "/bze.cointrunk.v1.MsgAddArticle": {
                    aminoType: string;
                    toAmino: ({ publisher, title, url, picture }: _19.MsgAddArticle) => {
                        publisher: string;
                        title: string;
                        url: string;
                        picture: string;
                    };
                    fromAmino: ({ publisher, title, url, picture }: {
                        publisher: string;
                        title: string;
                        url: string;
                        picture: string;
                    }) => _19.MsgAddArticle;
                };
                "/bze.cointrunk.v1.MsgPayPublisherRespect": {
                    aminoType: string;
                    toAmino: ({ creator, address, amount }: _19.MsgPayPublisherRespect) => {
                        creator: string;
                        address: string;
                        amount: string;
                    };
                    fromAmino: ({ creator, address, amount }: {
                        creator: string;
                        address: string;
                        amount: string;
                    }) => _19.MsgPayPublisherRespect;
                };
            };
            MsgAddArticle: {
                encode(message: _19.MsgAddArticle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _19.MsgAddArticle;
                fromPartial(object: {
                    publisher?: string;
                    title?: string;
                    url?: string;
                    picture?: string;
                }): _19.MsgAddArticle;
            };
            MsgAddArticleResponse: {
                encode(_: _19.MsgAddArticleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _19.MsgAddArticleResponse;
                fromPartial(_: {}): _19.MsgAddArticleResponse;
            };
            MsgPayPublisherRespect: {
                encode(message: _19.MsgPayPublisherRespect, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _19.MsgPayPublisherRespect;
                fromPartial(object: {
                    creator?: string;
                    address?: string;
                    amount?: string;
                }): _19.MsgPayPublisherRespect;
            };
            MsgPayPublisherRespectResponse: {
                encode(message: _19.MsgPayPublisherRespectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _19.MsgPayPublisherRespectResponse;
                fromPartial(object: {
                    respectPaid?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    publisherReward?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolFunds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _19.MsgPayPublisherRespectResponse;
            };
            QueryParamsRequest: {
                encode(_: _18.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryParamsRequest;
                fromPartial(_: {}): _18.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _18.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryParamsResponse;
                fromPartial(object: {
                    params?: {
                        anonArticleLimit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        anonArticleCost?: {
                            denom?: string;
                            amount?: string;
                        };
                        publisherRespectParams?: {
                            tax?: string;
                            denom?: string;
                        };
                    };
                }): _18.QueryParamsResponse;
            };
            QueryAcceptedDomainRequest: {
                encode(message: _18.QueryAcceptedDomainRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAcceptedDomainRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _18.QueryAcceptedDomainRequest;
            };
            QueryAcceptedDomainResponse: {
                encode(message: _18.QueryAcceptedDomainResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAcceptedDomainResponse;
                fromPartial(object: {
                    acceptedDomain?: {
                        domain?: string;
                        active?: boolean;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _18.QueryAcceptedDomainResponse;
            };
            QueryPublisherRequest: {
                encode(message: _18.QueryPublisherRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryPublisherRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _18.QueryPublisherRequest;
            };
            QueryPublisherResponse: {
                encode(message: _18.QueryPublisherResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryPublisherResponse;
                fromPartial(object: {
                    publisher?: {
                        name?: string;
                        address?: string;
                        active?: boolean;
                        articlesCount?: number;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        respect?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _18.QueryPublisherResponse;
            };
            QueryPublisherByIndexRequest: {
                encode(message: _18.QueryPublisherByIndexRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryPublisherByIndexRequest;
                fromPartial(object: {
                    index?: string;
                }): _18.QueryPublisherByIndexRequest;
            };
            QueryPublisherByIndexResponse: {
                encode(message: _18.QueryPublisherByIndexResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryPublisherByIndexResponse;
                fromPartial(object: {
                    publisher?: {
                        name?: string;
                        address?: string;
                        active?: boolean;
                        articlesCount?: number;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        respect?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _18.QueryPublisherByIndexResponse;
            };
            QueryAllArticlesRequest: {
                encode(message: _18.QueryAllArticlesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAllArticlesRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _18.QueryAllArticlesRequest;
            };
            QueryAllArticlesResponse: {
                encode(message: _18.QueryAllArticlesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAllArticlesResponse;
                fromPartial(object: {
                    article?: {
                        id?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        title?: string;
                        url?: string;
                        picture?: string;
                        publisher?: string;
                        paid?: boolean;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _18.QueryAllArticlesResponse;
            };
            QueryAllAnonArticlesCountersRequest: {
                encode(message: _18.QueryAllAnonArticlesCountersRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAllAnonArticlesCountersRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _18.QueryAllAnonArticlesCountersRequest;
            };
            QueryAllAnonArticlesCountersResponse: {
                encode(message: _18.QueryAllAnonArticlesCountersResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.QueryAllAnonArticlesCountersResponse;
                fromPartial(object: {
                    AnonArticlesCounters?: {
                        key?: string;
                        counter?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _18.QueryAllAnonArticlesCountersResponse;
            };
            Publisher: {
                encode(message: _17.Publisher, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _17.Publisher;
                fromPartial(object: {
                    name?: string;
                    address?: string;
                    active?: boolean;
                    articlesCount?: number;
                    createdAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    respect?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _17.Publisher;
            };
            PublisherProposal: {
                encode(message: _16.PublisherProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _16.PublisherProposal;
                fromPartial(object: {
                    title?: string;
                    description?: string;
                    name?: string;
                    address?: string;
                    active?: boolean;
                }): _16.PublisherProposal;
            };
            PublisherRespectParams: {
                encode(message: _15.PublisherRespectParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _15.PublisherRespectParams;
                fromPartial(object: {
                    tax?: string;
                    denom?: string;
                }): _15.PublisherRespectParams;
            };
            Params: {
                encode(message: _15.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _15.Params;
                fromPartial(object: {
                    anonArticleLimit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    anonArticleCost?: {
                        denom?: string;
                        amount?: string;
                    };
                    publisherRespectParams?: {
                        tax?: string;
                        denom?: string;
                    };
                }): _15.Params;
            };
            GenesisState: {
                encode(message: _14.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _14.GenesisState;
                fromPartial(object: {
                    params?: {
                        anonArticleLimit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        anonArticleCost?: {
                            denom?: string;
                            amount?: string;
                        };
                        publisherRespectParams?: {
                            tax?: string;
                            denom?: string;
                        };
                    };
                    publisherList?: {
                        name?: string;
                        address?: string;
                        active?: boolean;
                        articlesCount?: number;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        respect?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    acceptedDomainList?: {
                        domain?: string;
                        active?: boolean;
                    }[];
                    articleList?: {
                        id?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        title?: string;
                        url?: string;
                        picture?: string;
                        publisher?: string;
                        paid?: boolean;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                    articlesCounter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _14.GenesisState;
            };
            ArticleAddedEvent: {
                encode(message: _13.ArticleAddedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.ArticleAddedEvent;
                fromPartial(object: {
                    publisher?: string;
                    articleId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    paid?: boolean;
                }): _13.ArticleAddedEvent;
            };
            PublisherAddedEvent: {
                encode(message: _13.PublisherAddedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.PublisherAddedEvent;
                fromPartial(object: {
                    publisher?: {
                        name?: string;
                        address?: string;
                        active?: boolean;
                        articlesCount?: number;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        respect?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _13.PublisherAddedEvent;
            };
            PublisherUpdatedEvent: {
                encode(message: _13.PublisherUpdatedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.PublisherUpdatedEvent;
                fromPartial(object: {
                    publisher?: {
                        name?: string;
                        address?: string;
                        active?: boolean;
                        articlesCount?: number;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        respect?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _13.PublisherUpdatedEvent;
            };
            AcceptedDomainAddedEvent: {
                encode(message: _13.AcceptedDomainAddedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.AcceptedDomainAddedEvent;
                fromPartial(object: {
                    acceptedDomain?: {
                        domain?: string;
                        active?: boolean;
                    };
                }): _13.AcceptedDomainAddedEvent;
            };
            AcceptedDomainUpdatedEvent: {
                encode(message: _13.AcceptedDomainUpdatedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.AcceptedDomainUpdatedEvent;
                fromPartial(object: {
                    acceptedDomain?: {
                        domain?: string;
                        active?: boolean;
                    };
                }): _13.AcceptedDomainUpdatedEvent;
            };
            PublisherRespectPaidEvent: {
                encode(message: _13.PublisherRespectPaidEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _13.PublisherRespectPaidEvent;
                fromPartial(object: {
                    respectPaid?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    publisherReward?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolFunds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    publisher?: string;
                }): _13.PublisherRespectPaidEvent;
            };
            Article: {
                encode(message: _12.Article, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _12.Article;
                fromPartial(object: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    title?: string;
                    url?: string;
                    picture?: string;
                    publisher?: string;
                    paid?: boolean;
                    createdAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _12.Article;
            };
            AnonArticlesCounter: {
                encode(message: _11.AnonArticlesCounter, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _11.AnonArticlesCounter;
                fromPartial(object: {
                    key?: string;
                    counter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _11.AnonArticlesCounter;
            };
            AcceptedDomain: {
                encode(message: _10.AcceptedDomain, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _10.AcceptedDomain;
                fromPartial(object: {
                    domain?: string;
                    active?: boolean;
                }): _10.AcceptedDomain;
            };
            AcceptedDomainProposal: {
                encode(message: _9.AcceptedDomainProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _9.AcceptedDomainProposal;
                fromPartial(object: {
                    title?: string;
                    description?: string;
                    domain?: string;
                    active?: boolean;
                }): _9.AcceptedDomainProposal;
            };
        };
    }
    namespace epochs {
        const v1: {
            QueryClientImpl: typeof _200.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                epochInfos(request?: _22.QueryEpochsInfoRequest): Promise<_22.QueryEpochsInfoResponse>;
                currentEpoch(request: _22.QueryCurrentEpochRequest): Promise<_22.QueryCurrentEpochResponse>;
            };
            LCDQueryClient: typeof _194.LCDQueryClient;
            QueryEpochsInfoRequest: {
                encode(_: _22.QueryEpochsInfoRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _22.QueryEpochsInfoRequest;
                fromPartial(_: {}): _22.QueryEpochsInfoRequest;
            };
            QueryEpochsInfoResponse: {
                encode(message: _22.QueryEpochsInfoResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _22.QueryEpochsInfoResponse;
                fromPartial(object: {
                    epochs?: {
                        identifier?: string;
                        startTime?: Date;
                        duration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        currentEpoch?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        currentEpochStartTime?: Date;
                        epochCountingStarted?: boolean;
                        currentEpochStartHeight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                }): _22.QueryEpochsInfoResponse;
            };
            QueryCurrentEpochRequest: {
                encode(message: _22.QueryCurrentEpochRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _22.QueryCurrentEpochRequest;
                fromPartial(object: {
                    identifier?: string;
                }): _22.QueryCurrentEpochRequest;
            };
            QueryCurrentEpochResponse: {
                encode(message: _22.QueryCurrentEpochResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _22.QueryCurrentEpochResponse;
                fromPartial(object: {
                    currentEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _22.QueryCurrentEpochResponse;
            };
            EpochInfo: {
                encode(message: _21.EpochInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _21.EpochInfo;
                fromPartial(object: {
                    identifier?: string;
                    startTime?: Date;
                    duration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    currentEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    currentEpochStartTime?: Date;
                    epochCountingStarted?: boolean;
                    currentEpochStartHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _21.EpochInfo;
            };
            GenesisState: {
                encode(message: _21.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _21.GenesisState;
                fromPartial(object: {
                    epochs?: {
                        identifier?: string;
                        startTime?: Date;
                        duration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        currentEpoch?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        currentEpochStartTime?: Date;
                        epochCountingStarted?: boolean;
                        currentEpochStartHeight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                }): _21.GenesisState;
            };
            EpochStartEvent: {
                encode(message: _20.EpochStartEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _20.EpochStartEvent;
                fromPartial(object: {
                    identifier?: string;
                    epoch?: string;
                }): _20.EpochStartEvent;
            };
            EpochEndEvent: {
                encode(message: _20.EpochEndEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _20.EpochEndEvent;
                fromPartial(object: {
                    identifier?: string;
                    epoch?: string;
                }): _20.EpochEndEvent;
            };
        };
    }
    namespace rewards {
        const v1: {
            StakingRewardCreateEvent: {
                encode(message: _23.StakingRewardCreateEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardCreateEvent;
                fromPartial(object: {
                    rewardId?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    stakingDenom?: string;
                    duration?: number;
                    minStake?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    lock?: number;
                }): _23.StakingRewardCreateEvent;
            };
            StakingRewardUpdateEvent: {
                encode(message: _23.StakingRewardUpdateEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardUpdateEvent;
                fromPartial(object: {
                    rewardId?: string;
                    duration?: number;
                }): _23.StakingRewardUpdateEvent;
            };
            StakingRewardClaimEvent: {
                encode(message: _23.StakingRewardClaimEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardClaimEvent;
                fromPartial(object: {
                    rewardId?: string;
                    address?: string;
                    amount?: string;
                }): _23.StakingRewardClaimEvent;
            };
            StakingRewardJoinEvent: {
                encode(message: _23.StakingRewardJoinEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardJoinEvent;
                fromPartial(object: {
                    rewardId?: string;
                    address?: string;
                    amount?: string;
                }): _23.StakingRewardJoinEvent;
            };
            StakingRewardExitEvent: {
                encode(message: _23.StakingRewardExitEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardExitEvent;
                fromPartial(object: {
                    rewardId?: string;
                    address?: string;
                }): _23.StakingRewardExitEvent;
            };
            StakingRewardFinishEvent: {
                encode(message: _23.StakingRewardFinishEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardFinishEvent;
                fromPartial(object: {
                    rewardId?: string;
                }): _23.StakingRewardFinishEvent;
            };
            StakingRewardDistributionEvent: {
                encode(message: _23.StakingRewardDistributionEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.StakingRewardDistributionEvent;
                fromPartial(object: {
                    rewardId?: string;
                    amount?: string;
                }): _23.StakingRewardDistributionEvent;
            };
            TradingRewardCreateEvent: {
                encode(message: _23.TradingRewardCreateEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.TradingRewardCreateEvent;
                fromPartial(object: {
                    rewardId?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    duration?: number;
                    marketId?: string;
                    slots?: number;
                    creator?: string;
                }): _23.TradingRewardCreateEvent;
            };
            TradingRewardExpireEvent: {
                encode(message: _23.TradingRewardExpireEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.TradingRewardExpireEvent;
                fromPartial(object: {
                    rewardId?: string;
                }): _23.TradingRewardExpireEvent;
            };
            TradingRewardActivationEvent: {
                encode(message: _23.TradingRewardActivationEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.TradingRewardActivationEvent;
                fromPartial(object: {
                    rewardId?: string;
                }): _23.TradingRewardActivationEvent;
            };
            TradingRewardDistributionEvent: {
                encode(message: _23.TradingRewardDistributionEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _23.TradingRewardDistributionEvent;
                fromPartial(object: {
                    rewardId?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    winners?: string[];
                }): _23.TradingRewardDistributionEvent;
            };
        };
    }
    namespace v1 {
        const rewards: {
            MsgClientImpl: typeof _206.MsgClientImpl;
            QueryClientImpl: typeof _201.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _27.QueryParamsRequest): Promise<_27.QueryParamsResponse>;
                stakingReward(request: _27.QueryGetStakingRewardRequest): Promise<_27.QueryGetStakingRewardResponse>;
                stakingRewardAll(request?: _27.QueryAllStakingRewardRequest): Promise<_27.QueryAllStakingRewardResponse>;
                tradingReward(request: _27.QueryGetTradingRewardRequest): Promise<_27.QueryGetTradingRewardResponse>;
                tradingRewardAll(request: _27.QueryAllTradingRewardRequest): Promise<_27.QueryAllTradingRewardResponse>;
                stakingRewardParticipant(request: _27.QueryGetStakingRewardParticipantRequest): Promise<_27.QueryGetStakingRewardParticipantResponse>;
                stakingRewardParticipantAll(request?: _27.QueryAllStakingRewardParticipantRequest): Promise<_27.QueryAllStakingRewardParticipantResponse>;
                getTradingRewardLeaderboardHandler(request: _27.QueryGetTradingRewardLeaderboardRequest): Promise<_27.QueryGetTradingRewardLeaderboardResponse>;
                getMarketIdTradingRewardIdHandler(request: _27.QueryGetMarketIdTradingRewardIdHandlerRequest): Promise<_27.QueryGetMarketIdTradingRewardIdHandlerResponse>;
            };
            LCDQueryClient: typeof _195.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    createStakingReward(value: _31.MsgCreateStakingReward): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    updateStakingReward(value: _31.MsgUpdateStakingReward): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    createTradingReward(value: _31.MsgCreateTradingReward): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    joinStaking(value: _31.MsgJoinStaking): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    exitStaking(value: _31.MsgExitStaking): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    claimStakingRewards(value: _31.MsgClaimStakingRewards): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    distributeStakingRewards(value: _31.MsgDistributeStakingRewards): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    createStakingReward(value: _31.MsgCreateStakingReward): {
                        typeUrl: string;
                        value: _31.MsgCreateStakingReward;
                    };
                    updateStakingReward(value: _31.MsgUpdateStakingReward): {
                        typeUrl: string;
                        value: _31.MsgUpdateStakingReward;
                    };
                    createTradingReward(value: _31.MsgCreateTradingReward): {
                        typeUrl: string;
                        value: _31.MsgCreateTradingReward;
                    };
                    joinStaking(value: _31.MsgJoinStaking): {
                        typeUrl: string;
                        value: _31.MsgJoinStaking;
                    };
                    exitStaking(value: _31.MsgExitStaking): {
                        typeUrl: string;
                        value: _31.MsgExitStaking;
                    };
                    claimStakingRewards(value: _31.MsgClaimStakingRewards): {
                        typeUrl: string;
                        value: _31.MsgClaimStakingRewards;
                    };
                    distributeStakingRewards(value: _31.MsgDistributeStakingRewards): {
                        typeUrl: string;
                        value: _31.MsgDistributeStakingRewards;
                    };
                };
                fromPartial: {
                    createStakingReward(value: _31.MsgCreateStakingReward): {
                        typeUrl: string;
                        value: _31.MsgCreateStakingReward;
                    };
                    updateStakingReward(value: _31.MsgUpdateStakingReward): {
                        typeUrl: string;
                        value: _31.MsgUpdateStakingReward;
                    };
                    createTradingReward(value: _31.MsgCreateTradingReward): {
                        typeUrl: string;
                        value: _31.MsgCreateTradingReward;
                    };
                    joinStaking(value: _31.MsgJoinStaking): {
                        typeUrl: string;
                        value: _31.MsgJoinStaking;
                    };
                    exitStaking(value: _31.MsgExitStaking): {
                        typeUrl: string;
                        value: _31.MsgExitStaking;
                    };
                    claimStakingRewards(value: _31.MsgClaimStakingRewards): {
                        typeUrl: string;
                        value: _31.MsgClaimStakingRewards;
                    };
                    distributeStakingRewards(value: _31.MsgDistributeStakingRewards): {
                        typeUrl: string;
                        value: _31.MsgDistributeStakingRewards;
                    };
                };
            };
            AminoConverter: {
                "/bze.v1.rewards.MsgCreateStakingReward": {
                    aminoType: string;
                    toAmino: ({ creator, prizeAmount, prizeDenom, stakingDenom, duration, minStake, lock }: _31.MsgCreateStakingReward) => {
                        creator: string;
                        prize_amount: string;
                        prize_denom: string;
                        staking_denom: string;
                        duration: string;
                        min_stake: string;
                        lock: string;
                    };
                    fromAmino: ({ creator, prize_amount, prize_denom, staking_denom, duration, min_stake, lock }: {
                        creator: string;
                        prize_amount: string;
                        prize_denom: string;
                        staking_denom: string;
                        duration: string;
                        min_stake: string;
                        lock: string;
                    }) => _31.MsgCreateStakingReward;
                };
                "/bze.v1.rewards.MsgUpdateStakingReward": {
                    aminoType: string;
                    toAmino: ({ creator, rewardId, duration }: _31.MsgUpdateStakingReward) => {
                        creator: string;
                        reward_id: string;
                        duration: string;
                    };
                    fromAmino: ({ creator, reward_id, duration }: {
                        creator: string;
                        reward_id: string;
                        duration: string;
                    }) => _31.MsgUpdateStakingReward;
                };
                "/bze.v1.rewards.MsgCreateTradingReward": {
                    aminoType: string;
                    toAmino: ({ creator, prizeAmount, prizeDenom, duration, marketId, slots }: _31.MsgCreateTradingReward) => {
                        creator: string;
                        prize_amount: string;
                        prize_denom: string;
                        duration: string;
                        market_id: string;
                        slots: string;
                    };
                    fromAmino: ({ creator, prize_amount, prize_denom, duration, market_id, slots }: {
                        creator: string;
                        prize_amount: string;
                        prize_denom: string;
                        duration: string;
                        market_id: string;
                        slots: string;
                    }) => _31.MsgCreateTradingReward;
                };
                "/bze.v1.rewards.MsgJoinStaking": {
                    aminoType: string;
                    toAmino: ({ creator, rewardId, amount }: _31.MsgJoinStaking) => {
                        creator: string;
                        reward_id: string;
                        amount: string;
                    };
                    fromAmino: ({ creator, reward_id, amount }: {
                        creator: string;
                        reward_id: string;
                        amount: string;
                    }) => _31.MsgJoinStaking;
                };
                "/bze.v1.rewards.MsgExitStaking": {
                    aminoType: string;
                    toAmino: ({ creator, rewardId }: _31.MsgExitStaking) => {
                        creator: string;
                        rewardId: string;
                    };
                    fromAmino: ({ creator, rewardId }: {
                        creator: string;
                        rewardId: string;
                    }) => _31.MsgExitStaking;
                };
                "/bze.v1.rewards.MsgClaimStakingRewards": {
                    aminoType: string;
                    toAmino: ({ creator, rewardId }: _31.MsgClaimStakingRewards) => {
                        creator: string;
                        rewardId: string;
                    };
                    fromAmino: ({ creator, rewardId }: {
                        creator: string;
                        rewardId: string;
                    }) => _31.MsgClaimStakingRewards;
                };
                "/bze.v1.rewards.MsgDistributeStakingRewards": {
                    aminoType: string;
                    toAmino: ({ creator, rewardId, amount }: _31.MsgDistributeStakingRewards) => {
                        creator: string;
                        rewardId: string;
                        amount: string;
                    };
                    fromAmino: ({ creator, rewardId, amount }: {
                        creator: string;
                        rewardId: string;
                        amount: string;
                    }) => _31.MsgDistributeStakingRewards;
                };
            };
            MsgCreateStakingReward: {
                encode(message: _31.MsgCreateStakingReward, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgCreateStakingReward;
                fromPartial(object: {
                    creator?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    stakingDenom?: string;
                    duration?: string;
                    minStake?: string;
                    lock?: string;
                }): _31.MsgCreateStakingReward;
            };
            MsgCreateStakingRewardResponse: {
                encode(message: _31.MsgCreateStakingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgCreateStakingRewardResponse;
                fromPartial(object: {
                    rewardId?: string;
                }): _31.MsgCreateStakingRewardResponse;
            };
            MsgUpdateStakingReward: {
                encode(message: _31.MsgUpdateStakingReward, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgUpdateStakingReward;
                fromPartial(object: {
                    creator?: string;
                    rewardId?: string;
                    duration?: string;
                }): _31.MsgUpdateStakingReward;
            };
            MsgUpdateStakingRewardResponse: {
                encode(_: _31.MsgUpdateStakingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgUpdateStakingRewardResponse;
                fromPartial(_: {}): _31.MsgUpdateStakingRewardResponse;
            };
            MsgCreateTradingReward: {
                encode(message: _31.MsgCreateTradingReward, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgCreateTradingReward;
                fromPartial(object: {
                    creator?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    duration?: string;
                    marketId?: string;
                    slots?: string;
                }): _31.MsgCreateTradingReward;
            };
            MsgCreateTradingRewardResponse: {
                encode(message: _31.MsgCreateTradingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgCreateTradingRewardResponse;
                fromPartial(object: {
                    rewardId?: string;
                }): _31.MsgCreateTradingRewardResponse;
            };
            MsgJoinStaking: {
                encode(message: _31.MsgJoinStaking, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgJoinStaking;
                fromPartial(object: {
                    creator?: string;
                    rewardId?: string;
                    amount?: string;
                }): _31.MsgJoinStaking;
            };
            MsgJoinStakingResponse: {
                encode(_: _31.MsgJoinStakingResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgJoinStakingResponse;
                fromPartial(_: {}): _31.MsgJoinStakingResponse;
            };
            MsgExitStaking: {
                encode(message: _31.MsgExitStaking, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgExitStaking;
                fromPartial(object: {
                    creator?: string;
                    rewardId?: string;
                }): _31.MsgExitStaking;
            };
            MsgExitStakingResponse: {
                encode(_: _31.MsgExitStakingResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgExitStakingResponse;
                fromPartial(_: {}): _31.MsgExitStakingResponse;
            };
            MsgClaimStakingRewards: {
                encode(message: _31.MsgClaimStakingRewards, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgClaimStakingRewards;
                fromPartial(object: {
                    creator?: string;
                    rewardId?: string;
                }): _31.MsgClaimStakingRewards;
            };
            MsgClaimStakingRewardsResponse: {
                encode(message: _31.MsgClaimStakingRewardsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgClaimStakingRewardsResponse;
                fromPartial(object: {
                    amount?: string;
                }): _31.MsgClaimStakingRewardsResponse;
            };
            MsgDistributeStakingRewards: {
                encode(message: _31.MsgDistributeStakingRewards, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgDistributeStakingRewards;
                fromPartial(object: {
                    creator?: string;
                    rewardId?: string;
                    amount?: string;
                }): _31.MsgDistributeStakingRewards;
            };
            MsgDistributeStakingRewardsResponse: {
                encode(_: _31.MsgDistributeStakingRewardsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _31.MsgDistributeStakingRewardsResponse;
                fromPartial(_: {}): _31.MsgDistributeStakingRewardsResponse;
            };
            TradingReward: {
                encode(message: _30.TradingReward, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.TradingReward;
                fromPartial(object: {
                    rewardId?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    duration?: number;
                    marketId?: string;
                    slots?: number;
                    expireAt?: number;
                }): _30.TradingReward;
            };
            TradingRewardExpiration: {
                encode(message: _30.TradingRewardExpiration, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.TradingRewardExpiration;
                fromPartial(object: {
                    rewardId?: string;
                    expireAt?: number;
                }): _30.TradingRewardExpiration;
            };
            TradingRewardLeaderboard: {
                encode(message: _30.TradingRewardLeaderboard, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.TradingRewardLeaderboard;
                fromPartial(object: {
                    rewardId?: string;
                    list?: {
                        amount?: string;
                        address?: string;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                }): _30.TradingRewardLeaderboard;
            };
            TradingRewardLeaderboardEntry: {
                encode(message: _30.TradingRewardLeaderboardEntry, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.TradingRewardLeaderboardEntry;
                fromPartial(object: {
                    amount?: string;
                    address?: string;
                    createdAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _30.TradingRewardLeaderboardEntry;
            };
            TradingRewardCandidate: {
                encode(message: _30.TradingRewardCandidate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.TradingRewardCandidate;
                fromPartial(object: {
                    rewardId?: string;
                    amount?: string;
                    address?: string;
                }): _30.TradingRewardCandidate;
            };
            MarketIdTradingRewardId: {
                encode(message: _30.MarketIdTradingRewardId, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _30.MarketIdTradingRewardId;
                fromPartial(object: {
                    rewardId?: string;
                    marketId?: string;
                }): _30.MarketIdTradingRewardId;
            };
            StakingReward: {
                encode(message: _29.StakingReward, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _29.StakingReward;
                fromPartial(object: {
                    rewardId?: string;
                    prizeAmount?: string;
                    prizeDenom?: string;
                    stakingDenom?: string;
                    duration?: number;
                    payouts?: number;
                    minStake?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    lock?: number;
                    stakedAmount?: string;
                    distributedStake?: string;
                }): _29.StakingReward;
            };
            StakingRewardParticipant: {
                encode(message: _28.StakingRewardParticipant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _28.StakingRewardParticipant;
                fromPartial(object: {
                    address?: string;
                    rewardId?: string;
                    amount?: string;
                    joinedAt?: string;
                }): _28.StakingRewardParticipant;
            };
            PendingUnlockParticipant: {
                encode(message: _28.PendingUnlockParticipant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _28.PendingUnlockParticipant;
                fromPartial(object: {
                    index?: string;
                    address?: string;
                    amount?: string;
                    denom?: string;
                }): _28.PendingUnlockParticipant;
            };
            QueryParamsRequest: {
                encode(_: _27.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryParamsRequest;
                fromPartial(_: {}): _27.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _27.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryParamsResponse;
                fromPartial(object: {
                    params?: {
                        createStakingRewardFee?: string;
                        createTradingRewardFee?: string;
                    };
                }): _27.QueryParamsResponse;
            };
            QueryGetStakingRewardRequest: {
                encode(message: _27.QueryGetStakingRewardRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetStakingRewardRequest;
                fromPartial(object: {
                    rewardId?: string;
                }): _27.QueryGetStakingRewardRequest;
            };
            QueryGetStakingRewardResponse: {
                encode(message: _27.QueryGetStakingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetStakingRewardResponse;
                fromPartial(object: {
                    stakingReward?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        stakingDenom?: string;
                        duration?: number;
                        payouts?: number;
                        minStake?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        lock?: number;
                        stakedAmount?: string;
                        distributedStake?: string;
                    };
                }): _27.QueryGetStakingRewardResponse;
            };
            QueryAllStakingRewardRequest: {
                encode(message: _27.QueryAllStakingRewardRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllStakingRewardRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _27.QueryAllStakingRewardRequest;
            };
            QueryAllStakingRewardResponse: {
                encode(message: _27.QueryAllStakingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllStakingRewardResponse;
                fromPartial(object: {
                    list?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        stakingDenom?: string;
                        duration?: number;
                        payouts?: number;
                        minStake?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        lock?: number;
                        stakedAmount?: string;
                        distributedStake?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _27.QueryAllStakingRewardResponse;
            };
            QueryGetTradingRewardRequest: {
                encode(message: _27.QueryGetTradingRewardRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetTradingRewardRequest;
                fromPartial(object: {
                    rewardId?: string;
                }): _27.QueryGetTradingRewardRequest;
            };
            QueryGetTradingRewardResponse: {
                encode(message: _27.QueryGetTradingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetTradingRewardResponse;
                fromPartial(object: {
                    tradingReward?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        duration?: number;
                        marketId?: string;
                        slots?: number;
                        expireAt?: number;
                    };
                }): _27.QueryGetTradingRewardResponse;
            };
            QueryAllTradingRewardRequest: {
                encode(message: _27.QueryAllTradingRewardRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllTradingRewardRequest;
                fromPartial(object: {
                    state?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _27.QueryAllTradingRewardRequest;
            };
            QueryAllTradingRewardResponse: {
                encode(message: _27.QueryAllTradingRewardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllTradingRewardResponse;
                fromPartial(object: {
                    list?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        duration?: number;
                        marketId?: string;
                        slots?: number;
                        expireAt?: number;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _27.QueryAllTradingRewardResponse;
            };
            QueryGetStakingRewardParticipantRequest: {
                encode(message: _27.QueryGetStakingRewardParticipantRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetStakingRewardParticipantRequest;
                fromPartial(object: {
                    address?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _27.QueryGetStakingRewardParticipantRequest;
            };
            QueryGetStakingRewardParticipantResponse: {
                encode(message: _27.QueryGetStakingRewardParticipantResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetStakingRewardParticipantResponse;
                fromPartial(object: {
                    list?: {
                        address?: string;
                        rewardId?: string;
                        amount?: string;
                        joinedAt?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _27.QueryGetStakingRewardParticipantResponse;
            };
            QueryAllStakingRewardParticipantRequest: {
                encode(message: _27.QueryAllStakingRewardParticipantRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllStakingRewardParticipantRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _27.QueryAllStakingRewardParticipantRequest;
            };
            QueryAllStakingRewardParticipantResponse: {
                encode(message: _27.QueryAllStakingRewardParticipantResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryAllStakingRewardParticipantResponse;
                fromPartial(object: {
                    list?: {
                        address?: string;
                        rewardId?: string;
                        amount?: string;
                        joinedAt?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _27.QueryAllStakingRewardParticipantResponse;
            };
            QueryGetTradingRewardLeaderboardRequest: {
                encode(message: _27.QueryGetTradingRewardLeaderboardRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetTradingRewardLeaderboardRequest;
                fromPartial(object: {
                    rewardId?: string;
                }): _27.QueryGetTradingRewardLeaderboardRequest;
            };
            QueryGetTradingRewardLeaderboardResponse: {
                encode(message: _27.QueryGetTradingRewardLeaderboardResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetTradingRewardLeaderboardResponse;
                fromPartial(object: {
                    leaderboard?: {
                        rewardId?: string;
                        list?: {
                            amount?: string;
                            address?: string;
                            createdAt?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                        }[];
                    };
                }): _27.QueryGetTradingRewardLeaderboardResponse;
            };
            QueryGetMarketIdTradingRewardIdHandlerRequest: {
                encode(message: _27.QueryGetMarketIdTradingRewardIdHandlerRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetMarketIdTradingRewardIdHandlerRequest;
                fromPartial(object: {
                    marketId?: string;
                }): _27.QueryGetMarketIdTradingRewardIdHandlerRequest;
            };
            QueryGetMarketIdTradingRewardIdHandlerResponse: {
                encode(message: _27.QueryGetMarketIdTradingRewardIdHandlerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _27.QueryGetMarketIdTradingRewardIdHandlerResponse;
                fromPartial(object: {
                    marketIdRewardId?: {
                        rewardId?: string;
                        marketId?: string;
                    };
                }): _27.QueryGetMarketIdTradingRewardIdHandlerResponse;
            };
            Params: {
                encode(message: _26.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _26.Params;
                fromPartial(object: {
                    createStakingRewardFee?: string;
                    createTradingRewardFee?: string;
                }): _26.Params;
            };
            ActivateTradingRewardProposal: {
                encode(message: _25.ActivateTradingRewardProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _25.ActivateTradingRewardProposal;
                fromPartial(object: {
                    title?: string;
                    description?: string;
                    rewardId?: string;
                }): _25.ActivateTradingRewardProposal;
            };
            GenesisState: {
                encode(message: _24.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _24.GenesisState;
                fromPartial(object: {
                    params?: {
                        createStakingRewardFee?: string;
                        createTradingRewardFee?: string;
                    };
                    stakingRewardList?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        stakingDenom?: string;
                        duration?: number;
                        payouts?: number;
                        minStake?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        lock?: number;
                        stakedAmount?: string;
                        distributedStake?: string;
                    }[];
                    stakingRewardsCounter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    tradingRewardsCounter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    activeTradingRewardList?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        duration?: number;
                        marketId?: string;
                        slots?: number;
                        expireAt?: number;
                    }[];
                    pendingTradingRewardList?: {
                        rewardId?: string;
                        prizeAmount?: string;
                        prizeDenom?: string;
                        duration?: number;
                        marketId?: string;
                        slots?: number;
                        expireAt?: number;
                    }[];
                    stakingRewardParticipantList?: {
                        address?: string;
                        rewardId?: string;
                        amount?: string;
                        joinedAt?: string;
                    }[];
                    pendingUnlockParticipantList?: {
                        index?: string;
                        address?: string;
                        amount?: string;
                        denom?: string;
                    }[];
                    tradingRewardLeaderboardList?: {
                        rewardId?: string;
                        list?: {
                            amount?: string;
                            address?: string;
                            createdAt?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                        }[];
                    }[];
                    tradingRewardCandidateList?: {
                        rewardId?: string;
                        amount?: string;
                        address?: string;
                    }[];
                    marketIdTradingRewardIdList?: {
                        rewardId?: string;
                        marketId?: string;
                    }[];
                    pendingTradingRewardExpirationList?: {
                        rewardId?: string;
                        expireAt?: number;
                    }[];
                    activeTradingRewardExpirationList?: {
                        rewardId?: string;
                        expireAt?: number;
                    }[];
                }): _24.GenesisState;
            };
        };
    }
    namespace tokenfactory {
        const v1: {
            MsgClientImpl: typeof _207.MsgClientImpl;
            QueryClientImpl: typeof _202.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _35.QueryParamsRequest): Promise<_35.QueryParamsResponse>;
                denomAuthority(request: _35.QueryDenomAuthorityRequest): Promise<_35.QueryDenomAuthorityResponse>;
            };
            LCDQueryClient: typeof _196.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    createDenom(value: _36.MsgCreateDenom): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    mint(value: _36.MsgMint): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    burn(value: _36.MsgBurn): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    changeAdmin(value: _36.MsgChangeAdmin): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    setDenomMetadata(value: _36.MsgSetDenomMetadata): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    createDenom(value: _36.MsgCreateDenom): {
                        typeUrl: string;
                        value: _36.MsgCreateDenom;
                    };
                    mint(value: _36.MsgMint): {
                        typeUrl: string;
                        value: _36.MsgMint;
                    };
                    burn(value: _36.MsgBurn): {
                        typeUrl: string;
                        value: _36.MsgBurn;
                    };
                    changeAdmin(value: _36.MsgChangeAdmin): {
                        typeUrl: string;
                        value: _36.MsgChangeAdmin;
                    };
                    setDenomMetadata(value: _36.MsgSetDenomMetadata): {
                        typeUrl: string;
                        value: _36.MsgSetDenomMetadata;
                    };
                };
                fromPartial: {
                    createDenom(value: _36.MsgCreateDenom): {
                        typeUrl: string;
                        value: _36.MsgCreateDenom;
                    };
                    mint(value: _36.MsgMint): {
                        typeUrl: string;
                        value: _36.MsgMint;
                    };
                    burn(value: _36.MsgBurn): {
                        typeUrl: string;
                        value: _36.MsgBurn;
                    };
                    changeAdmin(value: _36.MsgChangeAdmin): {
                        typeUrl: string;
                        value: _36.MsgChangeAdmin;
                    };
                    setDenomMetadata(value: _36.MsgSetDenomMetadata): {
                        typeUrl: string;
                        value: _36.MsgSetDenomMetadata;
                    };
                };
            };
            AminoConverter: {
                "/bze.tokenfactory.v1.MsgCreateDenom": {
                    aminoType: string;
                    toAmino: ({ creator, subdenom }: _36.MsgCreateDenom) => {
                        creator: string;
                        subdenom: string;
                    };
                    fromAmino: ({ creator, subdenom }: {
                        creator: string;
                        subdenom: string;
                    }) => _36.MsgCreateDenom;
                };
                "/bze.tokenfactory.v1.MsgMint": {
                    aminoType: string;
                    toAmino: ({ creator, coins }: _36.MsgMint) => {
                        creator: string;
                        coins: string;
                    };
                    fromAmino: ({ creator, coins }: {
                        creator: string;
                        coins: string;
                    }) => _36.MsgMint;
                };
                "/bze.tokenfactory.v1.MsgBurn": {
                    aminoType: string;
                    toAmino: ({ creator, coins }: _36.MsgBurn) => {
                        creator: string;
                        coins: string;
                    };
                    fromAmino: ({ creator, coins }: {
                        creator: string;
                        coins: string;
                    }) => _36.MsgBurn;
                };
                "/bze.tokenfactory.v1.MsgChangeAdmin": {
                    aminoType: string;
                    toAmino: ({ creator, denom, newAdmin }: _36.MsgChangeAdmin) => {
                        creator: string;
                        denom: string;
                        newAdmin: string;
                    };
                    fromAmino: ({ creator, denom, newAdmin }: {
                        creator: string;
                        denom: string;
                        newAdmin: string;
                    }) => _36.MsgChangeAdmin;
                };
                "/bze.tokenfactory.v1.MsgSetDenomMetadata": {
                    aminoType: string;
                    toAmino: ({ creator, metadata }: _36.MsgSetDenomMetadata) => {
                        creator: string;
                        metadata: {
                            description: string;
                            denom_units: {
                                denom: string;
                                exponent: number;
                                aliases: string[];
                            }[];
                            base: string;
                            display: string;
                            name: string;
                            symbol: string;
                            uri: string;
                            uri_hash: string;
                        };
                    };
                    fromAmino: ({ creator, metadata }: {
                        creator: string;
                        metadata: {
                            description: string;
                            denom_units: {
                                denom: string;
                                exponent: number;
                                aliases: string[];
                            }[];
                            base: string;
                            display: string;
                            name: string;
                            symbol: string;
                            uri: string;
                            uri_hash: string;
                        };
                    }) => _36.MsgSetDenomMetadata;
                };
            };
            MsgCreateDenom: {
                encode(message: _36.MsgCreateDenom, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgCreateDenom;
                fromPartial(object: {
                    creator?: string;
                    subdenom?: string;
                }): _36.MsgCreateDenom;
            };
            MsgCreateDenomResponse: {
                encode(message: _36.MsgCreateDenomResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgCreateDenomResponse;
                fromPartial(object: {
                    newDenom?: string;
                }): _36.MsgCreateDenomResponse;
            };
            MsgMint: {
                encode(message: _36.MsgMint, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgMint;
                fromPartial(object: {
                    creator?: string;
                    coins?: string;
                }): _36.MsgMint;
            };
            MsgMintResponse: {
                encode(_: _36.MsgMintResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgMintResponse;
                fromPartial(_: {}): _36.MsgMintResponse;
            };
            MsgBurn: {
                encode(message: _36.MsgBurn, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgBurn;
                fromPartial(object: {
                    creator?: string;
                    coins?: string;
                }): _36.MsgBurn;
            };
            MsgBurnResponse: {
                encode(_: _36.MsgBurnResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgBurnResponse;
                fromPartial(_: {}): _36.MsgBurnResponse;
            };
            MsgChangeAdmin: {
                encode(message: _36.MsgChangeAdmin, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgChangeAdmin;
                fromPartial(object: {
                    creator?: string;
                    denom?: string;
                    newAdmin?: string;
                }): _36.MsgChangeAdmin;
            };
            MsgChangeAdminResponse: {
                encode(_: _36.MsgChangeAdminResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgChangeAdminResponse;
                fromPartial(_: {}): _36.MsgChangeAdminResponse;
            };
            MsgSetDenomMetadata: {
                encode(message: _36.MsgSetDenomMetadata, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgSetDenomMetadata;
                fromPartial(object: {
                    creator?: string;
                    metadata?: {
                        description?: string;
                        denomUnits?: {
                            denom?: string;
                            exponent?: number;
                            aliases?: string[];
                        }[];
                        base?: string;
                        display?: string;
                        name?: string;
                        symbol?: string;
                        uri?: string;
                        uriHash?: string;
                    };
                }): _36.MsgSetDenomMetadata;
            };
            MsgSetDenomMetadataResponse: {
                encode(_: _36.MsgSetDenomMetadataResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _36.MsgSetDenomMetadataResponse;
                fromPartial(_: {}): _36.MsgSetDenomMetadataResponse;
            };
            QueryParamsRequest: {
                encode(_: _35.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _35.QueryParamsRequest;
                fromPartial(_: {}): _35.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _35.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _35.QueryParamsResponse;
                fromPartial(object: {
                    params?: {
                        createDenomFee?: string;
                    };
                }): _35.QueryParamsResponse;
            };
            QueryDenomAuthorityRequest: {
                encode(message: _35.QueryDenomAuthorityRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _35.QueryDenomAuthorityRequest;
                fromPartial(object: {
                    denom?: string;
                }): _35.QueryDenomAuthorityRequest;
            };
            QueryDenomAuthorityResponse: {
                encode(message: _35.QueryDenomAuthorityResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _35.QueryDenomAuthorityResponse;
                fromPartial(object: {
                    denomAuthority?: {
                        admin?: string;
                    };
                }): _35.QueryDenomAuthorityResponse;
            };
            Params: {
                encode(message: _34.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _34.Params;
                fromPartial(object: {
                    createDenomFee?: string;
                }): _34.Params;
            };
            GenesisState: {
                encode(message: _33.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _33.GenesisState;
                fromPartial(object: {
                    params?: {
                        createDenomFee?: string;
                    };
                    factoryDenoms?: {
                        denom?: string;
                        denomAuthority?: {
                            admin?: string;
                        };
                    }[];
                }): _33.GenesisState;
            };
            GenesisDenom: {
                encode(message: _33.GenesisDenom, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _33.GenesisDenom;
                fromPartial(object: {
                    denom?: string;
                    denomAuthority?: {
                        admin?: string;
                    };
                }): _33.GenesisDenom;
            };
            DenomAuthority: {
                encode(message: _32.DenomAuthority, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _32.DenomAuthority;
                fromPartial(object: {
                    admin?: string;
                }): _32.DenomAuthority;
            };
        };
    }
    namespace tradebin {
        const v1: {
            MsgClientImpl: typeof _208.MsgClientImpl;
            QueryClientImpl: typeof _203.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _42.QueryParamsRequest): Promise<_42.QueryParamsResponse>;
                market(request: _42.QueryGetMarketRequest): Promise<_42.QueryGetMarketResponse>;
                marketAll(request?: _42.QueryAllMarketRequest): Promise<_42.QueryAllMarketResponse>;
                assetMarkets(request: _42.QueryAssetMarketsRequest): Promise<_42.QueryAssetMarketsResponse>;
                userMarketOrders(request: _42.QueryUserMarketOrdersRequest): Promise<_42.QueryUserMarketOrdersResponse>;
                marketAggregatedOrders(request: _42.QueryMarketAggregatedOrdersRequest): Promise<_42.QueryMarketAggregatedOrdersResponse>;
                marketHistory(request: _42.QueryMarketHistoryRequest): Promise<_42.QueryMarketHistoryResponse>;
                marketOrder(request: _42.QueryMarketOrderRequest): Promise<_42.QueryMarketOrderResponse>;
            };
            LCDQueryClient: typeof _197.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    createMarket(value: _44.MsgCreateMarket): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    createOrder(value: _44.MsgCreateOrder): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    cancelOrder(value: _44.MsgCancelOrder): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    createMarket(value: _44.MsgCreateMarket): {
                        typeUrl: string;
                        value: _44.MsgCreateMarket;
                    };
                    createOrder(value: _44.MsgCreateOrder): {
                        typeUrl: string;
                        value: _44.MsgCreateOrder;
                    };
                    cancelOrder(value: _44.MsgCancelOrder): {
                        typeUrl: string;
                        value: _44.MsgCancelOrder;
                    };
                };
                fromPartial: {
                    createMarket(value: _44.MsgCreateMarket): {
                        typeUrl: string;
                        value: _44.MsgCreateMarket;
                    };
                    createOrder(value: _44.MsgCreateOrder): {
                        typeUrl: string;
                        value: _44.MsgCreateOrder;
                    };
                    cancelOrder(value: _44.MsgCancelOrder): {
                        typeUrl: string;
                        value: _44.MsgCancelOrder;
                    };
                };
            };
            AminoConverter: {
                "/bze.tradebin.v1.MsgCreateMarket": {
                    aminoType: string;
                    toAmino: ({ creator, base, quote }: _44.MsgCreateMarket) => {
                        creator: string;
                        base: string;
                        quote: string;
                    };
                    fromAmino: ({ creator, base, quote }: {
                        creator: string;
                        base: string;
                        quote: string;
                    }) => _44.MsgCreateMarket;
                };
                "/bze.tradebin.v1.MsgCreateOrder": {
                    aminoType: string;
                    toAmino: ({ creator, orderType, amount, price, marketId }: _44.MsgCreateOrder) => {
                        creator: string;
                        order_type: string;
                        amount: string;
                        price: string;
                        marketId: string;
                    };
                    fromAmino: ({ creator, order_type, amount, price, marketId }: {
                        creator: string;
                        order_type: string;
                        amount: string;
                        price: string;
                        marketId: string;
                    }) => _44.MsgCreateOrder;
                };
                "/bze.tradebin.v1.MsgCancelOrder": {
                    aminoType: string;
                    toAmino: ({ creator, marketId, orderId, orderType }: _44.MsgCancelOrder) => {
                        creator: string;
                        marketId: string;
                        orderId: string;
                        order_type: string;
                    };
                    fromAmino: ({ creator, marketId, orderId, order_type }: {
                        creator: string;
                        marketId: string;
                        orderId: string;
                        order_type: string;
                    }) => _44.MsgCancelOrder;
                };
            };
            MsgCreateMarket: {
                encode(message: _44.MsgCreateMarket, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCreateMarket;
                fromPartial(object: {
                    creator?: string;
                    base?: string;
                    quote?: string;
                }): _44.MsgCreateMarket;
            };
            MsgCreateMarketResponse: {
                encode(_: _44.MsgCreateMarketResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCreateMarketResponse;
                fromPartial(_: {}): _44.MsgCreateMarketResponse;
            };
            MsgCreateOrder: {
                encode(message: _44.MsgCreateOrder, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCreateOrder;
                fromPartial(object: {
                    creator?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                    marketId?: string;
                }): _44.MsgCreateOrder;
            };
            MsgCreateOrderResponse: {
                encode(_: _44.MsgCreateOrderResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCreateOrderResponse;
                fromPartial(_: {}): _44.MsgCreateOrderResponse;
            };
            MsgCancelOrder: {
                encode(message: _44.MsgCancelOrder, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCancelOrder;
                fromPartial(object: {
                    creator?: string;
                    marketId?: string;
                    orderId?: string;
                    orderType?: string;
                }): _44.MsgCancelOrder;
            };
            MsgCancelOrderResponse: {
                encode(_: _44.MsgCancelOrderResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _44.MsgCancelOrderResponse;
                fromPartial(_: {}): _44.MsgCancelOrderResponse;
            };
            QueueMessage: {
                encode(message: _43.QueueMessage, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _43.QueueMessage;
                fromPartial(object: {
                    messageId?: string;
                    marketId?: string;
                    messageType?: string;
                    amount?: string;
                    price?: string;
                    createdAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    orderId?: string;
                    orderType?: string;
                    owner?: string;
                }): _43.QueueMessage;
            };
            QueryParamsRequest: {
                encode(_: _42.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryParamsRequest;
                fromPartial(_: {}): _42.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _42.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryParamsResponse;
                fromPartial(object: {
                    params?: {
                        createMarketFee?: string;
                        marketMakerFee?: string;
                        marketTakerFee?: string;
                        makerFeeDestination?: string;
                        takerFeeDestination?: string;
                    };
                }): _42.QueryParamsResponse;
            };
            QueryGetMarketRequest: {
                encode(message: _42.QueryGetMarketRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryGetMarketRequest;
                fromPartial(object: {
                    base?: string;
                    quote?: string;
                }): _42.QueryGetMarketRequest;
            };
            QueryGetMarketResponse: {
                encode(message: _42.QueryGetMarketResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryGetMarketResponse;
                fromPartial(object: {
                    market?: {
                        base?: string;
                        quote?: string;
                        creator?: string;
                    };
                }): _42.QueryGetMarketResponse;
            };
            QueryAllMarketRequest: {
                encode(message: _42.QueryAllMarketRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryAllMarketRequest;
                fromPartial(object: {
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _42.QueryAllMarketRequest;
            };
            QueryAllMarketResponse: {
                encode(message: _42.QueryAllMarketResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryAllMarketResponse;
                fromPartial(object: {
                    market?: {
                        base?: string;
                        quote?: string;
                        creator?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _42.QueryAllMarketResponse;
            };
            QueryAssetMarketsRequest: {
                encode(message: _42.QueryAssetMarketsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryAssetMarketsRequest;
                fromPartial(object: {
                    asset?: string;
                }): _42.QueryAssetMarketsRequest;
            };
            QueryAssetMarketsResponse: {
                encode(message: _42.QueryAssetMarketsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryAssetMarketsResponse;
                fromPartial(object: {
                    base?: {
                        base?: string;
                        quote?: string;
                        creator?: string;
                    }[];
                    quote?: {
                        base?: string;
                        quote?: string;
                        creator?: string;
                    }[];
                }): _42.QueryAssetMarketsResponse;
            };
            QueryUserMarketOrdersRequest: {
                encode(message: _42.QueryUserMarketOrdersRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryUserMarketOrdersRequest;
                fromPartial(object: {
                    address?: string;
                    market?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _42.QueryUserMarketOrdersRequest;
            };
            QueryUserMarketOrdersResponse: {
                encode(message: _42.QueryUserMarketOrdersResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryUserMarketOrdersResponse;
                fromPartial(object: {
                    list?: {
                        id?: string;
                        marketId?: string;
                        orderType?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _42.QueryUserMarketOrdersResponse;
            };
            QueryMarketAggregatedOrdersRequest: {
                encode(message: _42.QueryMarketAggregatedOrdersRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketAggregatedOrdersRequest;
                fromPartial(object: {
                    market?: string;
                    orderType?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _42.QueryMarketAggregatedOrdersRequest;
            };
            QueryMarketAggregatedOrdersResponse: {
                encode(message: _42.QueryMarketAggregatedOrdersResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketAggregatedOrdersResponse;
                fromPartial(object: {
                    list?: {
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _42.QueryMarketAggregatedOrdersResponse;
            };
            QueryMarketHistoryRequest: {
                encode(message: _42.QueryMarketHistoryRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketHistoryRequest;
                fromPartial(object: {
                    market?: string;
                    pagination?: {
                        key?: Uint8Array;
                        offset?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        limit?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        countTotal?: boolean;
                        reverse?: boolean;
                    };
                }): _42.QueryMarketHistoryRequest;
            };
            QueryMarketHistoryResponse: {
                encode(message: _42.QueryMarketHistoryResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketHistoryResponse;
                fromPartial(object: {
                    list?: {
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                        executedAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        maker?: string;
                        taker?: string;
                    }[];
                    pagination?: {
                        nextKey?: Uint8Array;
                        total?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _42.QueryMarketHistoryResponse;
            };
            QueryMarketOrderRequest: {
                encode(message: _42.QueryMarketOrderRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketOrderRequest;
                fromPartial(object: {
                    market?: string;
                    orderType?: string;
                    orderId?: string;
                }): _42.QueryMarketOrderRequest;
            };
            QueryMarketOrderResponse: {
                encode(message: _42.QueryMarketOrderResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _42.QueryMarketOrderResponse;
                fromPartial(object: {
                    order?: {
                        id?: string;
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        owner?: string;
                    };
                }): _42.QueryMarketOrderResponse;
            };
            Params: {
                encode(message: _41.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _41.Params;
                fromPartial(object: {
                    createMarketFee?: string;
                    marketMakerFee?: string;
                    marketTakerFee?: string;
                    makerFeeDestination?: string;
                    takerFeeDestination?: string;
                }): _41.Params;
            };
            Order: {
                encode(message: _40.Order, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _40.Order;
                fromPartial(object: {
                    id?: string;
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                    createdAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    owner?: string;
                }): _40.Order;
            };
            OrderReference: {
                encode(message: _40.OrderReference, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _40.OrderReference;
                fromPartial(object: {
                    id?: string;
                    marketId?: string;
                    orderType?: string;
                }): _40.OrderReference;
            };
            AggregatedOrder: {
                encode(message: _40.AggregatedOrder, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _40.AggregatedOrder;
                fromPartial(object: {
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                }): _40.AggregatedOrder;
            };
            HistoryOrder: {
                encode(message: _40.HistoryOrder, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _40.HistoryOrder;
                fromPartial(object: {
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                    executedAt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    maker?: string;
                    taker?: string;
                }): _40.HistoryOrder;
            };
            Market: {
                encode(message: _39.Market, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _39.Market;
                fromPartial(object: {
                    base?: string;
                    quote?: string;
                    creator?: string;
                }): _39.Market;
            };
            GenesisState: {
                encode(message: _38.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _38.GenesisState;
                fromPartial(object: {
                    params?: {
                        createMarketFee?: string;
                        marketMakerFee?: string;
                        marketTakerFee?: string;
                        makerFeeDestination?: string;
                        takerFeeDestination?: string;
                    };
                    marketList?: {
                        base?: string;
                        quote?: string;
                        creator?: string;
                    }[];
                    queueMessageList?: {
                        messageId?: string;
                        marketId?: string;
                        messageType?: string;
                        amount?: string;
                        price?: string;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        orderId?: string;
                        orderType?: string;
                        owner?: string;
                    }[];
                    orderList?: {
                        id?: string;
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                        createdAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        owner?: string;
                    }[];
                    aggregatedOrderList?: {
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                    }[];
                    historyOrderList?: {
                        marketId?: string;
                        orderType?: string;
                        amount?: string;
                        price?: string;
                        executedAt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        maker?: string;
                        taker?: string;
                    }[];
                    orderCounter?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _38.GenesisState;
            };
            OrderCreateMessageEvent: {
                encode(message: _37.OrderCreateMessageEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.OrderCreateMessageEvent;
                fromPartial(object: {
                    creator?: string;
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                }): _37.OrderCreateMessageEvent;
            };
            OrderCancelMessageEvent: {
                encode(message: _37.OrderCancelMessageEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.OrderCancelMessageEvent;
                fromPartial(object: {
                    creator?: string;
                    marketId?: string;
                    orderId?: string;
                    orderType?: string;
                }): _37.OrderCancelMessageEvent;
            };
            MarketCreatedEvent: {
                encode(message: _37.MarketCreatedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.MarketCreatedEvent;
                fromPartial(object: {
                    creator?: string;
                    base?: string;
                    quote?: string;
                }): _37.MarketCreatedEvent;
            };
            OrderExecutedEvent: {
                encode(message: _37.OrderExecutedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.OrderExecutedEvent;
                fromPartial(object: {
                    id?: string;
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                }): _37.OrderExecutedEvent;
            };
            OrderCanceledEvent: {
                encode(message: _37.OrderCanceledEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.OrderCanceledEvent;
                fromPartial(object: {
                    id?: string;
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                }): _37.OrderCanceledEvent;
            };
            OrderSavedEvent: {
                encode(message: _37.OrderSavedEvent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _37.OrderSavedEvent;
                fromPartial(object: {
                    id?: string;
                    marketId?: string;
                    orderType?: string;
                    amount?: string;
                    price?: string;
                }): _37.OrderSavedEvent;
            };
        };
    }
    const ClientFactory: {
        createRPCMsgClient: ({ rpc }: {
            rpc: import("../helpers").Rpc;
        }) => Promise<{
            bze: {
                burner: {
                    v1: _204.MsgClientImpl;
                };
                cointrunk: {
                    v1: _205.MsgClientImpl;
                };
                v1: {
                    rewards: _206.MsgClientImpl;
                };
                tokenfactory: {
                    v1: _207.MsgClientImpl;
                };
                tradebin: {
                    v1: _208.MsgClientImpl;
                };
            };
            cosmos: {
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                crisis: {
                    v1beta1: import("../cosmos/crisis/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/tx.rpc.msg").MsgClientImpl;
                    v1beta1: import("../cosmos/gov/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                group: {
                    v1: import("../cosmos/group/v1/tx.rpc.msg").MsgClientImpl;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                vesting: {
                    v1beta1: import("../cosmos/vesting/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
            };
        }>;
        createRPCQueryClient: ({ rpcEndpoint }: {
            rpcEndpoint: string | import("@cosmjs/tendermint-rpc").HttpEndpoint;
        }) => Promise<{
            bze: {
                burner: {
                    v1: {
                        params(request?: _6.QueryParamsRequest): Promise<_6.QueryParamsResponse>;
                        raffles(request?: _6.QueryRafflesRequest): Promise<_6.QueryRafflesResponse>;
                        raffleWinners(request: _6.QueryRaffleWinnersRequest): Promise<_6.QueryRaffleWinnersResponse>;
                        allBurnedCoins(request?: _6.QueryAllBurnedCoinsRequest): Promise<_6.QueryAllBurnedCoinsResponse>;
                    };
                };
                cointrunk: {
                    v1: {
                        params(request?: _18.QueryParamsRequest): Promise<_18.QueryParamsResponse>;
                        acceptedDomain(request?: _18.QueryAcceptedDomainRequest): Promise<_18.QueryAcceptedDomainResponse>;
                        publisher(request?: _18.QueryPublisherRequest): Promise<_18.QueryPublisherResponse>;
                        publisherByIndex(request: _18.QueryPublisherByIndexRequest): Promise<_18.QueryPublisherByIndexResponse>;
                        allArticles(request?: _18.QueryAllArticlesRequest): Promise<_18.QueryAllArticlesResponse>;
                        allAnonArticlesCounters(request?: _18.QueryAllAnonArticlesCountersRequest): Promise<_18.QueryAllAnonArticlesCountersResponse>;
                    };
                };
                epochs: {
                    v1: {
                        epochInfos(request?: _22.QueryEpochsInfoRequest): Promise<_22.QueryEpochsInfoResponse>;
                        currentEpoch(request: _22.QueryCurrentEpochRequest): Promise<_22.QueryCurrentEpochResponse>;
                    };
                };
                v1: {
                    rewards: {
                        params(request?: _27.QueryParamsRequest): Promise<_27.QueryParamsResponse>;
                        stakingReward(request: _27.QueryGetStakingRewardRequest): Promise<_27.QueryGetStakingRewardResponse>;
                        stakingRewardAll(request?: _27.QueryAllStakingRewardRequest): Promise<_27.QueryAllStakingRewardResponse>;
                        tradingReward(request: _27.QueryGetTradingRewardRequest): Promise<_27.QueryGetTradingRewardResponse>;
                        tradingRewardAll(request: _27.QueryAllTradingRewardRequest): Promise<_27.QueryAllTradingRewardResponse>;
                        stakingRewardParticipant(request: _27.QueryGetStakingRewardParticipantRequest): Promise<_27.QueryGetStakingRewardParticipantResponse>;
                        stakingRewardParticipantAll(request?: _27.QueryAllStakingRewardParticipantRequest): Promise<_27.QueryAllStakingRewardParticipantResponse>;
                        getTradingRewardLeaderboardHandler(request: _27.QueryGetTradingRewardLeaderboardRequest): Promise<_27.QueryGetTradingRewardLeaderboardResponse>;
                        getMarketIdTradingRewardIdHandler(request: _27.QueryGetMarketIdTradingRewardIdHandlerRequest): Promise<_27.QueryGetMarketIdTradingRewardIdHandlerResponse>;
                    };
                };
                tokenfactory: {
                    v1: {
                        params(request?: _35.QueryParamsRequest): Promise<_35.QueryParamsResponse>;
                        denomAuthority(request: _35.QueryDenomAuthorityRequest): Promise<_35.QueryDenomAuthorityResponse>;
                    };
                };
                tradebin: {
                    v1: {
                        params(request?: _42.QueryParamsRequest): Promise<_42.QueryParamsResponse>;
                        market(request: _42.QueryGetMarketRequest): Promise<_42.QueryGetMarketResponse>;
                        marketAll(request?: _42.QueryAllMarketRequest): Promise<_42.QueryAllMarketResponse>;
                        assetMarkets(request: _42.QueryAssetMarketsRequest): Promise<_42.QueryAssetMarketsResponse>;
                        userMarketOrders(request: _42.QueryUserMarketOrdersRequest): Promise<_42.QueryUserMarketOrdersResponse>;
                        marketAggregatedOrders(request: _42.QueryMarketAggregatedOrdersRequest): Promise<_42.QueryMarketAggregatedOrdersResponse>;
                        marketHistory(request: _42.QueryMarketHistoryRequest): Promise<_42.QueryMarketHistoryResponse>;
                        marketOrder(request: _42.QueryMarketOrderRequest): Promise<_42.QueryMarketOrderResponse>;
                    };
                };
            };
            cosmos: {
                app: {
                    v1alpha1: {
                        config(request?: import("../cosmos/app/v1alpha1/query").QueryConfigRequest): Promise<import("../cosmos/app/v1alpha1/query").QueryConfigResponse>;
                    };
                };
                auth: {
                    v1beta1: {
                        accounts(request?: import("../cosmos/auth/v1beta1/query").QueryAccountsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountsResponse>;
                        account(request: import("../cosmos/auth/v1beta1/query").QueryAccountRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountResponse>;
                        params(request?: import("../cosmos/auth/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryParamsResponse>;
                        moduleAccounts(request?: import("../cosmos/auth/v1beta1/query").QueryModuleAccountsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryModuleAccountsResponse>;
                        bech32Prefix(request?: import("../cosmos/auth/v1beta1/query").Bech32PrefixRequest): Promise<import("../cosmos/auth/v1beta1/query").Bech32PrefixResponse>;
                        addressBytesToString(request: import("../cosmos/auth/v1beta1/query").AddressBytesToStringRequest): Promise<import("../cosmos/auth/v1beta1/query").AddressBytesToStringResponse>;
                        addressStringToBytes(request: import("../cosmos/auth/v1beta1/query").AddressStringToBytesRequest): Promise<import("../cosmos/auth/v1beta1/query").AddressStringToBytesResponse>;
                    };
                };
                authz: {
                    v1beta1: {
                        grants(request: import("../cosmos/authz/v1beta1/query").QueryGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGrantsResponse>;
                        granterGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranterGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranterGrantsResponse>;
                        granteeGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsResponse>;
                    };
                };
                bank: {
                    v1beta1: {
                        balance(request: import("../cosmos/bank/v1beta1/query").QueryBalanceRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryBalanceResponse>;
                        allBalances(request: import("../cosmos/bank/v1beta1/query").QueryAllBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryAllBalancesResponse>;
                        spendableBalances(request: import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesResponse>;
                        totalSupply(request?: import("../cosmos/bank/v1beta1/query").QueryTotalSupplyRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryTotalSupplyResponse>;
                        supplyOf(request: import("../cosmos/bank/v1beta1/query").QuerySupplyOfRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySupplyOfResponse>;
                        params(request?: import("../cosmos/bank/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryParamsResponse>;
                        denomMetadata(request: import("../cosmos/bank/v1beta1/query").QueryDenomMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomMetadataResponse>;
                        denomsMetadata(request?: import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataResponse>;
                        denomOwners(request: import("../cosmos/bank/v1beta1/query").QueryDenomOwnersRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomOwnersResponse>;
                    };
                };
                base: {
                    tendermint: {
                        v1beta1: {
                            getNodeInfo(request?: import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoResponse>;
                            getSyncing(request?: import("../cosmos/base/tendermint/v1beta1/query").GetSyncingRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetSyncingResponse>;
                            getLatestBlock(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockResponse>;
                            getBlockByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightResponse>;
                            getLatestValidatorSet(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetResponse>;
                            getValidatorSetByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightResponse>;
                        };
                    };
                };
                distribution: {
                    v1beta1: {
                        params(request?: import("../cosmos/distribution/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryParamsResponse>;
                        validatorOutstandingRewards(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsResponse>;
                        validatorCommission(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionResponse>;
                        validatorSlashes(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesResponse>;
                        delegationRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsResponse>;
                        delegationTotalRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsResponse>;
                        delegatorValidators(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorWithdrawAddress(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressResponse>;
                        communityPool(request?: import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolResponse>;
                    };
                };
                evidence: {
                    v1beta1: {
                        evidence(request: import("../cosmos/evidence/v1beta1/query").QueryEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryEvidenceResponse>;
                        allEvidence(request?: import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceResponse>;
                    };
                };
                feegrant: {
                    v1beta1: {
                        allowance(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowanceRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowanceResponse>;
                        allowances(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesResponse>;
                        allowancesByGranter(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterResponse>;
                    };
                };
                gov: {
                    v1: {
                        proposal(request: import("../cosmos/gov/v1/query").QueryProposalRequest): Promise<import("../cosmos/gov/v1/query").QueryProposalResponse>;
                        proposals(request: import("../cosmos/gov/v1/query").QueryProposalsRequest): Promise<import("../cosmos/gov/v1/query").QueryProposalsResponse>;
                        vote(request: import("../cosmos/gov/v1/query").QueryVoteRequest): Promise<import("../cosmos/gov/v1/query").QueryVoteResponse>;
                        votes(request: import("../cosmos/gov/v1/query").QueryVotesRequest): Promise<import("../cosmos/gov/v1/query").QueryVotesResponse>;
                        params(request: import("../cosmos/gov/v1/query").QueryParamsRequest): Promise<import("../cosmos/gov/v1/query").QueryParamsResponse>;
                        deposit(request: import("../cosmos/gov/v1/query").QueryDepositRequest): Promise<import("../cosmos/gov/v1/query").QueryDepositResponse>;
                        deposits(request: import("../cosmos/gov/v1/query").QueryDepositsRequest): Promise<import("../cosmos/gov/v1/query").QueryDepositsResponse>;
                        tallyResult(request: import("../cosmos/gov/v1/query").QueryTallyResultRequest): Promise<import("../cosmos/gov/v1/query").QueryTallyResultResponse>;
                    };
                    v1beta1: {
                        proposal(request: import("../cosmos/gov/v1beta1/query").QueryProposalRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalResponse>;
                        proposals(request: import("../cosmos/gov/v1beta1/query").QueryProposalsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalsResponse>;
                        vote(request: import("../cosmos/gov/v1beta1/query").QueryVoteRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVoteResponse>;
                        votes(request: import("../cosmos/gov/v1beta1/query").QueryVotesRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVotesResponse>;
                        params(request: import("../cosmos/gov/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryParamsResponse>;
                        deposit(request: import("../cosmos/gov/v1beta1/query").QueryDepositRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositResponse>;
                        deposits(request: import("../cosmos/gov/v1beta1/query").QueryDepositsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositsResponse>;
                        tallyResult(request: import("../cosmos/gov/v1beta1/query").QueryTallyResultRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryTallyResultResponse>;
                    };
                };
                group: {
                    v1: {
                        groupInfo(request: import("../cosmos/group/v1/query").QueryGroupInfoRequest): Promise<import("../cosmos/group/v1/query").QueryGroupInfoResponse>;
                        groupPolicyInfo(request: import("../cosmos/group/v1/query").QueryGroupPolicyInfoRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPolicyInfoResponse>;
                        groupMembers(request: import("../cosmos/group/v1/query").QueryGroupMembersRequest): Promise<import("../cosmos/group/v1/query").QueryGroupMembersResponse>;
                        groupsByAdmin(request: import("../cosmos/group/v1/query").QueryGroupsByAdminRequest): Promise<import("../cosmos/group/v1/query").QueryGroupsByAdminResponse>;
                        groupPoliciesByGroup(request: import("../cosmos/group/v1/query").QueryGroupPoliciesByGroupRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPoliciesByGroupResponse>;
                        groupPoliciesByAdmin(request: import("../cosmos/group/v1/query").QueryGroupPoliciesByAdminRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPoliciesByAdminResponse>;
                        proposal(request: import("../cosmos/group/v1/query").QueryProposalRequest): Promise<import("../cosmos/group/v1/query").QueryProposalResponse>;
                        proposalsByGroupPolicy(request: import("../cosmos/group/v1/query").QueryProposalsByGroupPolicyRequest): Promise<import("../cosmos/group/v1/query").QueryProposalsByGroupPolicyResponse>;
                        voteByProposalVoter(request: import("../cosmos/group/v1/query").QueryVoteByProposalVoterRequest): Promise<import("../cosmos/group/v1/query").QueryVoteByProposalVoterResponse>;
                        votesByProposal(request: import("../cosmos/group/v1/query").QueryVotesByProposalRequest): Promise<import("../cosmos/group/v1/query").QueryVotesByProposalResponse>;
                        votesByVoter(request: import("../cosmos/group/v1/query").QueryVotesByVoterRequest): Promise<import("../cosmos/group/v1/query").QueryVotesByVoterResponse>;
                        groupsByMember(request: import("../cosmos/group/v1/query").QueryGroupsByMemberRequest): Promise<import("../cosmos/group/v1/query").QueryGroupsByMemberResponse>;
                        tallyResult(request: import("../cosmos/group/v1/query").QueryTallyResultRequest): Promise<import("../cosmos/group/v1/query").QueryTallyResultResponse>;
                    };
                };
                mint: {
                    v1beta1: {
                        params(request?: import("../cosmos/mint/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryParamsResponse>;
                        inflation(request?: import("../cosmos/mint/v1beta1/query").QueryInflationRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryInflationResponse>;
                        annualProvisions(request?: import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsResponse>;
                    };
                };
                nft: {
                    v1beta1: {
                        balance(request: import("../cosmos/nft/v1beta1/query").QueryBalanceRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryBalanceResponse>;
                        owner(request: import("../cosmos/nft/v1beta1/query").QueryOwnerRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryOwnerResponse>;
                        supply(request: import("../cosmos/nft/v1beta1/query").QuerySupplyRequest): Promise<import("../cosmos/nft/v1beta1/query").QuerySupplyResponse>;
                        nFTs(request: import("../cosmos/nft/v1beta1/query").QueryNFTsRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryNFTsResponse>;
                        nFT(request: import("../cosmos/nft/v1beta1/query").QueryNFTRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryNFTResponse>;
                        class(request: import("../cosmos/nft/v1beta1/query").QueryClassRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryClassResponse>;
                        classes(request?: import("../cosmos/nft/v1beta1/query").QueryClassesRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryClassesResponse>;
                    };
                };
                params: {
                    v1beta1: {
                        params(request: import("../cosmos/params/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/params/v1beta1/query").QueryParamsResponse>;
                        subspaces(request?: import("../cosmos/params/v1beta1/query").QuerySubspacesRequest): Promise<import("../cosmos/params/v1beta1/query").QuerySubspacesResponse>;
                    };
                };
                slashing: {
                    v1beta1: {
                        params(request?: import("../cosmos/slashing/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/slashing/v1beta1/query").QueryParamsResponse>;
                        signingInfo(request: import("../cosmos/slashing/v1beta1/query").QuerySigningInfoRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfoResponse>;
                        signingInfos(request?: import("../cosmos/slashing/v1beta1/query").QuerySigningInfosRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfosResponse>;
                    };
                };
                staking: {
                    v1beta1: {
                        validators(request: import("../cosmos/staking/v1beta1/query").QueryValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorsResponse>;
                        validator(request: import("../cosmos/staking/v1beta1/query").QueryValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorResponse>;
                        validatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsResponse>;
                        validatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsResponse>;
                        delegation(request: import("../cosmos/staking/v1beta1/query").QueryDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegationResponse>;
                        unbondingDelegation(request: import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationResponse>;
                        delegatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsResponse>;
                        delegatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsResponse>;
                        redelegations(request: import("../cosmos/staking/v1beta1/query").QueryRedelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryRedelegationsResponse>;
                        delegatorValidators(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorValidator(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorResponse>;
                        historicalInfo(request: import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoResponse>;
                        pool(request?: import("../cosmos/staking/v1beta1/query").QueryPoolRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryPoolResponse>;
                        params(request?: import("../cosmos/staking/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryParamsResponse>;
                    };
                };
                tx: {
                    v1beta1: {
                        simulate(request: import("../cosmos/tx/v1beta1/service").SimulateRequest): Promise<import("../cosmos/tx/v1beta1/service").SimulateResponse>;
                        getTx(request: import("../cosmos/tx/v1beta1/service").GetTxRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxResponse>;
                        broadcastTx(request: import("../cosmos/tx/v1beta1/service").BroadcastTxRequest): Promise<import("../cosmos/tx/v1beta1/service").BroadcastTxResponse>;
                        getTxsEvent(request: import("../cosmos/tx/v1beta1/service").GetTxsEventRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxsEventResponse>;
                        getBlockWithTxs(request: import("../cosmos/tx/v1beta1/service").GetBlockWithTxsRequest): Promise<import("../cosmos/tx/v1beta1/service").GetBlockWithTxsResponse>;
                    };
                };
                upgrade: {
                    v1beta1: {
                        currentPlan(request?: import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanResponse>;
                        appliedPlan(request: import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanResponse>;
                        upgradedConsensusState(request: import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateResponse>;
                        moduleVersions(request: import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsResponse>;
                        authority(request?: import("../cosmos/upgrade/v1beta1/query").QueryAuthorityRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryAuthorityResponse>;
                    };
                };
            };
        }>;
        createLCDClient: ({ restEndpoint }: {
            restEndpoint: string;
        }) => Promise<{
            bze: {
                burner: {
                    v1: _192.LCDQueryClient;
                };
                cointrunk: {
                    v1: _193.LCDQueryClient;
                };
                epochs: {
                    v1: _194.LCDQueryClient;
                };
                v1: {
                    rewards: _195.LCDQueryClient;
                };
                tokenfactory: {
                    v1: _196.LCDQueryClient;
                };
                tradebin: {
                    v1: _197.LCDQueryClient;
                };
            };
            cosmos: {
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/query.lcd").LCDQueryClient;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/query.lcd").LCDQueryClient;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/query.lcd").LCDQueryClient;
                };
                base: {
                    tendermint: {
                        v1beta1: import("../cosmos/base/tendermint/v1beta1/query.lcd").LCDQueryClient;
                    };
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/query.lcd").LCDQueryClient;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/query.lcd").LCDQueryClient;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/query.lcd").LCDQueryClient;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/query.lcd").LCDQueryClient;
                    v1beta1: import("../cosmos/gov/v1beta1/query.lcd").LCDQueryClient;
                };
                group: {
                    v1: import("../cosmos/group/v1/query.lcd").LCDQueryClient;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/query.lcd").LCDQueryClient;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/query.lcd").LCDQueryClient;
                };
                params: {
                    v1beta1: import("../cosmos/params/v1beta1/query.lcd").LCDQueryClient;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/query.lcd").LCDQueryClient;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/query.lcd").LCDQueryClient;
                };
                tx: {
                    v1beta1: import("../cosmos/tx/v1beta1/service.lcd").LCDQueryClient;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/query.lcd").LCDQueryClient;
                };
            };
        }>;
    };
}
